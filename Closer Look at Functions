/////////////////////////////////////////////////
//Default Parameters:-
const bookings = [];

const createBooking = function (flightNum, numPassengers=1, price=199*numPassengers) {// ES6
  //Traditional method: ES5
//   numPassengers = numPassengers || 1;
//   price = price || 199;

  const booking = {
    flightNum,
    numPassengers,
    price,
  };
  console.log(booking);
  bookings.push(booking);
};

createBooking('LH123');
createBooking('LH123', 2, 800); 
createBooking('LH123', 1);
createBooking('LH123',5)
createBooking('LH123', undefined, 1000);
//////////////////////////////////////////////////

//////////////////////////////////////////////////
//How passing argument works Value vs Reference:-
const flight = 'LH234';
const jonas = {
  name: 'Jonas Schmedtmann',
  passport: 22357972032,
};

const checkIn = function (flightNum, passenger) {
  flightNum = 'LH999';
  passenger.name = 'Mr. ' + passenger.name;

  if (passenger.passport === 22357972032) {
    alert('Checked In');
  } else {
    alert('Wrong Password!');
  }
};

checkIn(flight, jonas);

console.log(flight); //nothing changed
console.log(jonas); //changed with extra Mr.
//so this flight here is a primitive type and as we passed
that value into the function down here, then the flight number
here is basically a copy of that original value so flight number
contains a copy and not simply orighinal value of the flight
variable. So this would be exactly the same as writing "const
flightNum= flight" and this would also then simply copy this value
to fligthNum and so flightNum here is completely different variable
and therefore as we changed it here it did not get reflected in
the outside flight variable and so it's still LH234. But now what about
the Jonas object that we passed into the checkIn function and in that
function it is called passenger and then we changed that passenger
object and the jonas object was also affected by that change so why
did that happen? So when we pass a reference type to a fucntion, what
is copied is really just a reference to the object in the memory heap
so that would be exacly like doing thing "const passenger= joans" so
when we try to copy object like this we are only copying the reference
to that object in the memory heap but they both point to the same object
in the memory. So here as we are manipulating the passenger object, it is
exactly the same as manipulating the jonas object because they both are
the same object in the memory heap.

//another example:
const newPassport = function (person) {
  person.passport = Math.trunc(Math.random() * 10000000000);
};

newPassport(jonas);
checkIn(flight,jonas);
//so here the exact same thing is happening in the new passport function
I'm passing in an object and so that object here is then called person and
as the function manipulates that person object of course it also gets reflected
in jonas object. And then as we pass that jonas object into the checking function
then of course that passport is no longer the same as the origninal one.

//Note: Javascript does not have pass by reference it's a little bit confusing
because as we just learned for objects we do in fact pass in reference so that
is memory address of the object, however that reference itself is still a value,
it's simply a value that contains a memroy address. So basically we pass a reference
to the function but we do not pass by reference and this is an important distincition.
/////////////////////////////////////////////////

////////////////////////////////////////////////
//Fucntions accepting callback functions:-
const oneWord = function (str) {
  return str.replace(/ /g, '').toLowerCase();
};

const upperFirstWord = function (str) {
  const [first, ...others] = str.split(' ');
  return [first.toUpperCase(), ...others].join(' ');
};

//Higher order function: takes-in the function:
const transformer = function (str, fn) {
  console.log(`Original String: ${str}`);
  console.log(`Transformed String: ${fn(str)}`);
  console.log(`Transformed by: ${fn.name}`);
};

transformer('JavsScript is the best!', upperFirstWord);

transformer('JavsScript is the best!', oneWord);
//transformer is higher order function and fn is callback function.

//Javascript uses call backs all the time:
//advantages: makes code more readable
//2. abstraction: the higher function doesn't care about how things are getting done, it just wanna get his function done.

const high5 = function () {
  console.log('ðŸ™Œ');
};

document.body.addEventListener('click', high5);

['Jonas', 'Martha', 'Adam'].forEach(high5);

//////////////////////////////////////////////
//Functions returning function:-
const greet = function (greeting) {
  return function (name) {
    console.log(`${greeting} ${name}`);
  };
};

const greeterHey = greet('Hey');
greeterHey('Jonas');
greeterHey('Steven');
//here greet('Hey') returning the function which is stored in greetHey and when we call greetHey it runs and prints Hey jonas or steven.

greet('hello')('jonas');
//here greet('hello') returning function and simultaneously we have provided other argument for return fucntion and so it is giving output of hello jonas.

//Arrow representation of above function:
const greetArr = greeting => name => console.log(`${greeting} ${name}`);

greetArr('hi')('jonas');
///////////////////////////////////////////////
