/////////////////////////////////////////////////
//Simple Array Methods:-
let arr = ['a', 'b', 'c', 'd', 'e'];

//Slice method: creating copies of array
console.log(arr.slice(2));
console.log(arr.slice(2, 4));
console.log(arr.slice(-2));
console.log(arr.slice(-1));
console.log(arr.slice(1, -2));
//shallow copy of array:
console.log(arr.slice());
console.log([...arr]);

//Splice method: it mutates the original array

//console.log(arr.splice(2));
//extracted elements are actually gone from the original array
console.log(arr.splice(-1));
console.log(arr);
console.log(arr.splice(1, 2));
//the first parameter here works the same as in the slice method but the second one is really the number
of elements that we want to delete.
console.log(arr);

//Reverse method: it mutates the original array
arr = ['a', 'b', 'c', 'd', 'e'];
const arr2 = ['j', 'i', 'h', 'g', 'f'];
console.log(arr2.reverse());
console.log(arr2);

//Concat method: does not mutate the original array
const letters= arr.concat(arr2);
console.log(letters);
console.log([...arr,...arr2]);

//Join method: 
console.log(letters.join('-'));

//already known methods: push, unshift, pop, shift, indexof and includes. 
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//at method:-
const arr = [23, 11, 64];
console.log(arr[0]);
console.log(arr.at(0));

//special particularity of at method:-
//getting last array element
//traditional,
console.log(arr[arr.length - 1]);
console.log(arr.slice(-1)[0]);
//at method:
console.log(arr.at(-1));

//on strings:
console.log('jonas'.at(0));
console.log('jonas'.at(-1));
/////////////////////////////////////////////////
/////////////////////////////////////////////////
//Looping Arrays forEach:-
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

//with for of
for (const movement of movements) {
  if (movement > 0) {
    console.log(`You deposited ${movement}`);
  } else {
    console.log(`You withdrew ${Math.abs(movement)}`);
  }
}

//with forEach:
console.log('------FOREACH--------');

movements.forEach(function (movement) {
  if (movement > 0) {
    console.log(`You deposited ${movement}`);
  } else {
    console.log(`You withdrew ${Math.abs(movement)}`);
  }
});

//0: function(200)
//1: function(450)
//2: function(400)...and so on.
//here inside forEach there is a call back function and in each iteration it will take the
argument which is an index value itself.

//We use a callback function to tell other higher order function exactly what it should do
and so in this case we tell forEach that in each iteration it should log one of above two 
strings here to the console.

//extracting index with for of:
for (const [i, movement] of movements.entries()) {
  if (movement > 0) {
    console.log(`Movement ${i + 1}: You deposited ${movement}`);
  } else {
    console.log(`Movement ${i + 1}: You withdrew ${Math.abs(movement)}`);
  }
}

//extracting index with forEach method:
console.log('------FOREACH--------');

movements.forEach(function (movement, index, array) {
  if (movement > 0) {
    console.log(`Movement ${index + 1}: You deposited ${movement} ${array}`);
  } else {
    console.log(
      `Movement ${index + 1}: You withdrew ${Math.abs(movement)} ${array}`
    );
  }
});

//of course we can just use one parameter like we have been doing or we can just use two or
we can use all three together and as always the names here do not matter at all but what does 
matter is the order. So the first parameter always needs to be the current element and second
parameter always the current index and the third one always the entire array that we are looping
over because that's the order in which arguments so the actual values are passed into our call
back function.

//forEach vs for of loop:
//cannot use continue&break in forEach in forOf can so forEach will always loop over the entire
array and there is nothing that you can do about it.

//forEach with Maps and Sets:
//with map:
const currencies = new Map([
  ['USD', 'United States dollar'],
  ['EUR', 'Euro'],
  ['GBP', 'Pound sterling'],
]);

currencies.forEach(function (value, key, map) {
  console.log(`${key}: ${value}`);
});

//With Set:
const currenciesUnique = new Set(['USD', 'GBP', 'USD', 'EUR', 'EUR']);
console.log(currenciesUnique);

currenciesUnique.forEach(function (value, key, set) {
  console.log(`${key}: ${value}`);
});
//key here is exactly same as the value so why is that well a set doesn't have keys and it doesn't have
indexes either and so there is no value that would make sense for the key and so essentialy key above 
makes no sense at all it wouldn't even have to be there and so the people who designed this forEach method 
for sets they could've simply omitted the second argument, right? Well if they did that then this forEach 
would have been different from the others and so that would then create confusion in developers and therefore 
it was decided to keep the same signature.
