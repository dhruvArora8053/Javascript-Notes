/////////////////////////////////////////////////
//Simple Array Methods:-
let arr = ['a', 'b', 'c', 'd', 'e'];

//Slice method: creating copies of array
console.log(arr.slice(2));
console.log(arr.slice(2, 4));
console.log(arr.slice(-2));
console.log(arr.slice(-1));
console.log(arr.slice(1, -2));
//shallow copy of array:
console.log(arr.slice());
console.log([...arr]);

//Splice method: it mutates the original array

//console.log(arr.splice(2));
//extracted elements are actually gone from the original array
console.log(arr.splice(-1));
console.log(arr);
console.log(arr.splice(1, 2));
//the first parameter here works the same as in the slice method but the second one is really the number
of elements that we want to delete.
console.log(arr);

//Reverse method: it mutates the original array
arr = ['a', 'b', 'c', 'd', 'e'];
const arr2 = ['j', 'i', 'h', 'g', 'f'];
console.log(arr2.reverse());
console.log(arr2);

//Concat method: does not mutate the original array
const letters= arr.concat(arr2);
console.log(letters);
console.log([...arr,...arr2]);

//Join method: 
console.log(letters.join('-'));

//already known methods: push, unshift, pop, shift, indexof and includes. 
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//at method:-
const arr = [23, 11, 64];
console.log(arr[0]);
console.log(arr.at(0));

//special particularity of at method:-
//getting last array element
//traditional,
console.log(arr[arr.length - 1]);
console.log(arr.slice(-1)[0]);
//at method:
console.log(arr.at(-1));

//on strings:
console.log('jonas'.at(0));
console.log('jonas'.at(-1));
/////////////////////////////////////////////////
/////////////////////////////////////////////////
//Looping Arrays forEach:-
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

//with for of
for (const movement of movements) {
  if (movement > 0) {
    console.log(`You deposited ${movement}`);
  } else {
    console.log(`You withdrew ${Math.abs(movement)}`);
  }
}

//with forEach:
console.log('------FOREACH--------');

movements.forEach(function (movement) {
  if (movement > 0) {
    console.log(`You deposited ${movement}`);
  } else {
    console.log(`You withdrew ${Math.abs(movement)}`);
  }
});

//0: function(200)
//1: function(450)
//2: function(400)...and so on.
//here inside forEach there is a call back function and in each iteration it will take the
argument which is an index value itself.

//We use a callback function to tell other higher order function exactly what it should do
and so in this case we tell forEach that in each iteration it should log one of above two 
strings here to the console.

//extracting index with for of:
for (const [i, movement] of movements.entries()) {
  if (movement > 0) {
    console.log(`Movement ${i + 1}: You deposited ${movement}`);
  } else {
    console.log(`Movement ${i + 1}: You withdrew ${Math.abs(movement)}`);
  }
}

//extracting index with forEach method:
console.log('------FOREACH--------');

movements.forEach(function (movement, index, array) {
  if (movement > 0) {
    console.log(`Movement ${index + 1}: You deposited ${movement} ${array}`);
  } else {
    console.log(
      `Movement ${index + 1}: You withdrew ${Math.abs(movement)} ${array}`
    );
  }
});

//of course we can just use one parameter like we have been doing or we can just use two or
we can use all three together and as always the names here do not matter at all but what does 
matter is the order. So the first parameter always needs to be the current element and second
parameter always the current index and the third one always the entire array that we are looping
over because that's the order in which arguments so the actual values are passed into our call
back function.

//forEach vs for of loop:
//cannot use continue&break in forEach in forOf can so forEach will always loop over the entire
array and there is nothing that you can do about it.

//forEach with Maps and Sets:
//with map:
const currencies = new Map([
  ['USD', 'United States dollar'],
  ['EUR', 'Euro'],
  ['GBP', 'Pound sterling'],
]);

currencies.forEach(function (value, key, map) {
  console.log(`${key}: ${value}`);
});

//With Set:
const currenciesUnique = new Set(['USD', 'GBP', 'USD', 'EUR', 'EUR']);
console.log(currenciesUnique);

currenciesUnique.forEach(function (value, key, set) {
  console.log(`${key}: ${value}`);
});
//key here is exactly same as the value so why is that well a set doesn't have keys and it doesn't have
indexes either and so there is no value that would make sense for the key and so essentialy key above 
makes no sense at all it wouldn't even have to be there and so the people who designed this forEach method 
for sets they could've simply omitted the second argument, right? Well if they did that then this forEach 
would have been different from the others and so that would then create confusion in developers and therefore 
it was decided to keep the same signature.

////////////////////////////////////////////////
//Map method:-
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

const euroToUSD = 1.1;

const movementsUSD = movements.map(function (mov) {
  return mov * euroToUSD;
  //return 23;
});
console.log(movements);
console.log(movementsUSD);
//map method does not mutate the existing array it will make the copy of existing array
and this is used where we have do some operations on array elements

//with arrow:
const movementsUSDarrow = movements.map(mov => mov * euroToUSD);
console.log(movementsUSDarrow);

//with for of:
const movementsUSDfor = [];
for (const mov of movements) {
  movementsUSDfor.push(mov * euroToUSD);
}
console.log(movementsUSDfor);
//same result but this approach is not so ideal

//extracting val,i,arr in map:
const movementsDescription = movements.map(
  (mov, i, arr) =>
    `Movement ${i + 1}: You ${mov > 0 ? 'deposited' : 'withdrew'} ${Math.abs(
      mov
    )}`

  // if (mov > 0) {
  //   return `Movement ${i + 1}: You deposited ${mov}`;
  // } else {
  //   return `Movement ${i + 1}: You withdrew ${Math.abs(mov)}`;
  // }
);
console.log(movementsDescription);
//so one more time all we do here is to pass this callback funtion into map method but we
do not call this function by ourselves it is the map mehtod who will call this function for
each of the array elements in the movement array. Now each time that the map method calls or
callback it will simply pass in the current array element as well as the current index and 
the whole array.


//map vs foreach:
//now you could say that what we did above there with this map method is essentially the same
as what we did with the for each method but infact there is a bid difference between these two
approaches so before we printed each line individually to the console as we were looping over
the array so in each of the iterations we performed some action that was then visible in the
console and we can call this a side effect. So  the forEach method creates side effects but now
here with this map mehtod all we did was to return each of the strings from the callback and so
basically they got added into a new array and then we finally logged that entire array to the
console not elements one by one. And so here in this map method we did not create a side effect
in each of the iteration all we did was to build a brand new array and this idea of side effects 
will become important again as we talk more about functional programming.
///////////////////////////////////////////////// 

/////////////////////////////////////////////////
//Filter method:- it will filter out the required elements from the array and will create a new array
//filtering out the negative values:
const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];
const deposits = movements.filter(function (mov,i, arr) {
  return mov > 0;
});
console.log(movements);
console.log(deposits);

const withdrawals = movements.filter(mov => mov < 0);
console.log(withdrawals);

//with for of loop:
const depostisFor = [];
for (const mov of movements) mov > 0 ? depostisFor.push(mov) : null;
console.log(depostisFor);

//and so you could again ask what is the big difference here like what's the big deal why not just use
the four of loop for everything and the reason for that is again the push that exists in javascript 
using more functional code like this but there's also a more practical implication here and that's
because we can actuall chain all of these methods together.
//////////////////////////////////////////////////
